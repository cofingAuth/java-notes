## RabbitMQ
#### 1. 优点与缺点
	优点：解耦、异步、削峰
	缺点：系统可用性降低、系统复杂度提高、一致性问题

#### 2. 如何保证不丢失数据?
	生产端：
		1：开启事务（不推荐，太耗性能降低吞吐）
		2：开启 confirm 模式（推荐），生产者开启confirm模式之后，每次写的消息都会分配一个唯一id，然后写入rabbitmq，rabbitmq会回传一个ack消息，告诉你这个消息ok了；如果rabbitmq没能处理这个消息，会回调你的nack接口；而且你可以结合这个机制自己在内存里维护每个消息 id 的状态，如果超过一定时间还没接收到这个消息的回调，那么你可以重发。
	消息队列：
		开启持久化，即消息会持久化到磁盘；
		设置持久化有两个步骤：
		1：创建 queue 的时候将其设置为持久化，这样就可以保证 RabbitMQ 持久化 queue 的元数据，但是它是不会持久化 queue 里的数据的。
		2：第二个是发送消息的时候将消息的 deliveryMode 设置为 2。就是将消息设置为持久化的，此时 RabbitMQ 就会将消息持久化到磁盘上去。
	消费端：

## JAVA

#### 1. 



### 2. BIO、NIO、AIO的理解

	首先IO的理解：  
		IO分为两个阶段：
			1.数据准备阶段
			2.内核空间复制数据到用户进程缓冲区（用户空间）阶段
	阻塞IO与非阻塞IO的区别在于第一步发起IO请求是否被阻塞
	同步IO与异步IO的区别在于第二个步骤是否被阻塞
	
	BIO：同步阻塞IO，基于流模型实现，其特性就是做完一个件事再去做另外一件事，数据的读取写入必须阻塞在一个线程内等待完成，
	例如客户端发送请求后，先咨询服务端是否有线程相应，如果没有则会一直等待或者遭到拒绝请求
	
	NIO：同步非阻塞IO，提供了Channel、Buffer、Selector等新的抽象，使用多路复用器机制；以socker使用来说，多路复用器通过不断轮询各个连接的状态，
	只有在socket有流可读或者可写时，应用程序才需要去处理它，在线程的使用上，就不需要一个连接就必须使用一个处理线程了
	
	AIO：异步非阻塞IO，基于事件和回调机制，即AIO在数据准备好了后，就会通知数据使用者，不需要不停轮询了。使用的是系统底层API的支持，
	在Unix使用epoll IO模型，而windows使用locp模型

## Spring

### REST : GET、POST、PUT、DELETE、PATCH 等

	GET：获取
	POST：新增
	PUT：传完整的进行更新
	DELETE：删除
	PATCH：传部分进行更新



## Redis

#### 缓存穿透

> 缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。在流量大时，可能DB就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。
>
> 解决方案
>
> - 常见采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，进行拦截一定不存在的数据
>
> - 增加用户的鉴权校验，在知道的范围内id做基础检验，如id<=0的直接拦截
> - 将此查询key-null缓存设置过期时间较短，如30秒，防止反复用同一个id暴力攻击，此方法较为简单粗暴

#### 缓存击穿

> 指缓存中没有但数据库中有的数据（一般是缓存过期），这时由于并发用户多，同时读缓存没有，又同时去读数据库，引起数据库压力瞬间增加大
>
> 解决方案
>
> - 设置热点数据永久不过期
> - 加互斥锁
> - 检测更新：把过期时间一起保存到缓存中，每次获取时比较当前时间<=某个自定值如1，则主动更新缓存

#### 缓存雪崩

> 缓存雪崩是指在设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，导致所有的查询都落在数据库上，造成了缓存雪崩。
>
> 解决方案
>
> - 缓存数据的过期时间设置随机（加随机因子），防止同一时间大量数据过期现象发生
> - 设置热点数据永不过期
> - 双缓存策略。即A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期。



## 数据结构

> 常见的：数组、栈、队列、链表、树、图、字典树、散列表




​	